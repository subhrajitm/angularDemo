import { __extends } from 'tslib';
import { Observable } from 'rxjs';
import { finalize, shareReplay } from 'rxjs/operators';
import { NAVIGATOR } from '@ng-web-apis/common';
import { inject, InjectionToken, Inject, Injectable, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var GEOLOCATION = new InjectionToken('An abstraction over window.navigator.geolocation object', {
    factory: function () { return inject(NAVIGATOR).geolocation; },
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var POSITION_OPTIONS = new InjectionToken('Token for an additional position options', { factory: function () { return ({}); } });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var GEOLOCATION_SUPPORT = new InjectionToken('Is Geolocation API supported?', {
    factory: function () {
        return !!inject(GEOLOCATION);
    },
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Replace type with GeolocationPosition after bumping TS to 4.1.3+
// @dynamic
var GeolocationService = /** @class */ (function (_super) {
    __extends(GeolocationService, _super);
    function GeolocationService(geolocationRef, geolocationSupported, positionOptions) {
        var _this = this;
        /** @type {?} */
        var watchPositionId = 0;
        _this = _super.call(this, function (subscriber) {
            if (!geolocationSupported) {
                subscriber.error('Geolocation is not supported in your browser');
            }
            watchPositionId = geolocationRef.watchPosition(function (position) { return subscriber.next(position); }, function (positionError) { return subscriber.error(positionError); }, positionOptions);
        }) || this;
        return (/** @type {?} */ (_this.pipe(finalize(function () { return geolocationRef.clearWatch(watchPositionId); }), shareReplay({ bufferSize: 1, refCount: true }))));
    }
    GeolocationService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    GeolocationService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [GEOLOCATION,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [GEOLOCATION_SUPPORT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [POSITION_OPTIONS,] }] }
    ]; };
    /** @nocollapse */ GeolocationService.ngInjectableDef = defineInjectable({ factory: function GeolocationService_Factory() { return new GeolocationService(inject(GEOLOCATION), inject(GEOLOCATION_SUPPORT), inject(POSITION_OPTIONS)); }, token: GeolocationService, providedIn: "root" });
    return GeolocationService;
}(Observable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { GeolocationService, GEOLOCATION, POSITION_OPTIONS, GEOLOCATION_SUPPORT };

//# sourceMappingURL=ng-web-apis-geolocation.js.map